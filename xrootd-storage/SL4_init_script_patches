#!/bin/sh

# __proc_pids {program} [pidfile]
# Set $pid to pids from /var/run* for {program}.  $pid should be declared
# local in the caller.
# Returns LSB exit code for the 'status' action.
__pids_var_run() {
        local base=${1##*/}
        local pid_file=${2:-/var/run/$base.pid}

        pid=
        if [ -f "$pid_file" ] ; then
                local line p
                read line < "$pid_file"
                for p in $line ; do
                        [ -z "${p//[0-9]/}" -a -d "/proc/$p" ] && pid="$pid $p"
                done
                if [ -n "$pid" ]; then
                        return 0
                fi
                return 1 # "Program is dead and /var/run pid file exists"
        fi
        return 3 # "Program is not running"
}

# Output PIDs of matching processes, found using pidof
__pids_pidof() {
        pidof -o $$ -o $PPID -o %PPID -x "$1" || \
                pidof -o $$ -o $PPID -o %PPID -x "${1##*/}"
}

# A function to start a program.
daemon() {
        # Test syntax.
        local gotbase= force= nicelevel corelimit
        local pid base= user= nice= bg= pid_file=
        nicelevel=0
        while [ "$1" != "${1##[-+]}" ]; do
          case $1 in
            '')    echo $"$0: Usage: daemon [+/-nicelevel] {program}"
                   return 1;;
            --check)
                   base=$2
                   gotbase="yes"
                   shift 2
                   ;;
            --check=?*)
                   base=${1#--check=}
                   gotbase="yes"
                   shift
                   ;;
            --user)
                   user=$2
                   shift 2
                   ;;
            --user=?*)
                   user=${1#--user=}
                   shift
                   ;;
            --pidfile)
                   pid_file=$2
                   shift 2
                   ;;
            --pidfile=?*)
                   pid_file=${1#--pidfile=}
                   shift
                   ;;
            --force)
                   force="force"
                   shift
                   ;;
            [-+][0-9]*)
                   nice="nice -n $1"
                   shift
                   ;;
            *)     echo $"$0: Usage: daemon [+/-nicelevel] {program}"
                   return 1;;
          esac
        done
        # Save basename.
        [ -z "$gotbase" ] && base=${1##*/}

        # See if it's already running. Look *only* at the pid file.
        __pids_var_run "$base" "$pid_file"

        [ -n "$pid" -a -z "$force" ] && return

        # make sure it doesn't core dump anywhere unless requested
        corelimit="ulimit -S -c ${DAEMON_COREFILE_LIMIT:-0}"

        # if they set NICELEVEL in /etc/sysconfig/foo, honor it
        [ -n "${NICELEVEL:-}" ] && nice="nice -n $NICELEVEL"

        # Echo daemon
        [ "${BOOTUP:-}" = "verbose" -a -z "${LSB:-}" ] && echo -n " $base"

        # And start it up.
        if [ -z "$user" ]; then
           $nice /bin/bash -c "$corelimit >/dev/null 2>&1 ; $*"
        else
           $nice runuser -s /bin/bash - $user -c "$corelimit >/dev/null 2>&1 ; $*"
        fi
        [ "$?" -eq 0 ] && success $"$base startup" || failure $"$base startup"
}

# A function to stop a program.
killproc() {
        local RC killlevel= base pid pid_file= delay
        
        RC=0; delay=3
        # Test syntax.
        if [ "$#" -eq 0 ]; then
                echo $"Usage: killproc [-p pidfile] [ -d delay] {program} [-signal]"
                return 1
        fi      
        if [ "$1" = "-p" ]; then
                pid_file=$2 
                shift 2
        fi      
        if [ "$1" = "-d" ]; then
                delay=$2 
                shift 2
        fi      
        

        # check for second arg to be kill level
        [ -n "${2:-}" ] && killlevel=$2
        
        # Save basename.
        base=${1##*/}

        # Find pid.
        __pids_var_run "$1" "$pid_file"
        if [ -z "$pid_file" -a -z "$pid" ]; then
                pid="$(__pids_pidof "$1")"
        fi

        # Kill it.
        if [ -n "$pid" ] ; then
                [ "$BOOTUP" = "verbose" -a -z "${LSB:-}" ] && echo -n "$base "
                if [ -z "$killlevel" ] ; then
                       if checkpid $pid 2>&1; then
                           # TERM first, then KILL if not dead
                           kill -TERM $pid >/dev/null 2>&1
                           usleep 100000
                           if checkpid $pid && sleep 1 &&
                              checkpid $pid && sleep $delay &&
                              checkpid $pid ; then
                                kill -KILL $pid >/dev/null 2>&1
                                usleep 100000
                           fi
                        fi
                        checkpid $pid
                        RC=$?
                        [ "$RC" -eq 0 ] && failure $"$base shutdown" || success $"$base shutdown"
                        RC=$((! $RC))
                # use specified level only
                else
                        if checkpid $pid; then
                                kill $killlevel $pid >/dev/null 2>&1
                                RC=$?
                                [ "$RC" -eq 0 ] && success $"$base $killlevel" || failure $"$base $killlevel"
                        elif [ -n "${LSB:-}" ]; then
                                RC=7 # Program is not running
                        fi
                fi
        else
                if [ -n "${LSB:-}" -a -n "$killlevel" ]; then
                        RC=7 # Program is not running
                else
                        failure $"$base shutdown"
                        RC=0
                fi
        fi

        # Remove pid file if any.
        if [ -z "$killlevel" ]; then
            rm -f "${pid_file:-/var/run/$base.pid}"
        fi
        return $RC
}

status() {
        local base pid pid_file=

        # Test syntax.
        if [ "$#" = 0 ] ; then
                echo $"Usage: status [-p pidfile] {program}"
                return 1
        fi
        if [ "$1" = "-p" ]; then
                pid_file=$2
                shift 2
        fi
        base=${1##*/} 
                
        # First try "pidof"
        __pids_var_run "$1" "$pid_file"
        RC=$?
        if [ -z "$pid_file" -a -z "$pid" ]; then
                pid="$(__pids_pidof "$1")"
        fi
        if [ -n "$pid" ]; then
                echo $"${base} (pid $pid) is running..."
                return 0
        fi
        
        case "$RC" in
                0)
                        echo $"${base} (pid $pid) is running..."
                        return 0
                        ;;
                1)
                        echo $"${base} dead but pid file exists"
                        return 1
                        ;;
        esac
        # See if /var/lock/subsys/${base} exists
        if [ -f /var/lock/subsys/${base} ]; then
                echo $"${base} dead but subsys locked"
                return 2
        fi
        echo $"${base} is stopped"
        return 3
}               
